import React from 'react';
import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
  pdf,
  Font,
} from '@react-pdf/renderer';

// --- TİP TANIMLAMALARI ---
export interface PlanEntry {
  date: string;
  start: string;
  end: string;
  subjectId: string;
  topicId: string;
  allocated: number;
  remainingAfter: number;
  targetQuestionCount?: number; // Hedef Soru Sayısı
}

interface Subject {
  id: string;
  name: string;
  category?: string;
}

interface Topic {
  id: string;
  name: string;
  avgMinutes?: number;
}

// --- FONT KAYDI ---
Font.register({
  family: 'Roboto',
  fonts: [
    { src: 'https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf', fontWeight: 400 },
    { src: 'https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlvAx05IsDqlA.ttf', fontWeight: 700 },
  ],
});

// --- STİLLER ---
const styles = StyleSheet.create({
  page: { padding: 15, fontFamily: 'Roboto', backgroundColor: '#ffffff' },
  header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10, paddingBottom: 5, borderBottomWidth: 1.5, borderBottomColor: '#4f46e5' },
  headerLeft: { flexDirection: 'column' },
  title: { fontSize: 14, fontWeight: 700, color: '#1e3a5f' },
  subtitle: { fontSize: 8, color: '#64748b', marginTop: 2 },
  headerRight: { alignItems: 'flex-end' },
  studentName: { fontSize: 10, fontWeight: 700, color: '#1e3a5f' },
  dateRange: { fontSize: 8, color: '#475569', marginTop: 2 },
  
  // İstatistik Kartları
  statsRow: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8, gap: 5 },
  statCard: { flex: 1, backgroundColor: '#f8fafc', borderRadius: 4, padding: 5, alignItems: 'center', borderWidth: 1, borderColor: '#e2e8f0' },
  statValue: { fontSize: 10, fontWeight: 700, color: '#1e3a5f' },
  statLabel: { fontSize: 6, color: '#64748b', marginTop: 1, textTransform: 'uppercase' },

  // Ana İçerik
  mainContent: { flexDirection: 'row', gap: 8, flex: 1 },
  column: { flex: 1 },
  daySection: { marginBottom: 6, borderRadius: 3, overflow: 'hidden', borderWidth: 1, borderColor: '#e2e8f0' },
  dayHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', backgroundColor: '#4f46e5', paddingVertical: 3, paddingHorizontal: 5 },
  dayName: { fontSize: 8, fontWeight: 700, color: '#ffffff' },
  dayDate: { fontSize: 7, color: '#cbd5e1' },
  dayContent: { backgroundColor: '#ffffff' },

  // Tablo Yapısı
  tableHeader: { flexDirection: 'row', backgroundColor: '#f1f5f9', paddingVertical: 2, paddingHorizontal: 2, borderBottomWidth: 0.5, borderBottomColor: '#cbd5e1' },
  tableHeaderText: { fontSize: 5, fontWeight: 700, color: '#475569', textAlign: 'center' },
  topicRow: { flexDirection: 'row', alignItems: 'center', paddingVertical: 2, paddingHorizontal: 2, borderBottomWidth: 0.5, borderBottomColor: '#f1f5f9', minHeight: 14 },
  topicRowLast: { borderBottomWidth: 0 },

  // Sütun Genişlikleri (Optimize Edilmiş)
  colTime: { width: '12%' },
  colCategorySubject: { width: '22%' },
  colTopic: { width: '28%' },
  colTarget: { width: '10%', alignItems: 'center' }, // HEDEF SÜTUNU
  colSolved: { width: '10%', alignItems: 'center' },
  colCorrect: { width: '9%', alignItems: 'center' },
  colWrong: { width: '9%', alignItems: 'center' },

  // Metin Stilleri
  timeText: { fontSize: 5, fontWeight: 700, color: '#1e3a5f' },
  subjectText: { fontSize: 5, color: '#334155', fontWeight: 700 },
  topicText: { fontSize: 5, color: '#475569' },
  
  // Kategori Etiketi
  categoryBadge: { paddingHorizontal: 3, paddingVertical: 1, borderRadius: 2, alignSelf: 'flex-start', marginBottom: 1 },
  categoryText: { fontSize: 4, fontWeight: 700, color: '#ffffff' },
  
  // Girdi Kutuları ve Hedef
  targetText: { fontSize: 5, fontWeight: 700, color: '#ea580c' }, // Turuncu hedef sayısı
  inputBox: { width: 14, height: 9, borderWidth: 0.5, borderColor: '#cbd5e1', borderRadius: 2, backgroundColor: '#fafafa' },

  // Alt Bilgi
  footer: { marginTop: 5, paddingTop: 5, borderTopWidth: 1, borderTopColor: '#e2e8f0' },
  notesTitle: { fontSize: 7, fontWeight: 700, color: '#1e3a5f', marginBottom: 2 },
  notesGrid: { flexDirection: 'row', gap: 5 },
  noteColumn: { flex: 1 },
  noteBox: { height: 25, borderWidth: 1, borderColor: '#e2e8f0', borderRadius: 2, backgroundColor: '#fafafa', marginBottom: 2 },
  noteLabel: { fontSize: 5, fontWeight: 700, color: '#64748b', textAlign: 'center' },
  branding: { marginTop: 4, alignItems: 'center' },
  brandText: { fontSize: 5, color: '#94a3b8' },
});

// --- YARDIMCI FONKSİYONLAR ---
const DAYS = [
  { value: 1, label: 'Pazartesi' }, { value: 2, label: 'Salı' }, { value: 3, label: 'Çarşamba' },
  { value: 4, label: 'Perşembe' }, { value: 5, label: 'Cuma' }, { value: 6, label: 'Cumartesi' }, { value: 7, label: 'Pazar' },
];

function dateFromWeekStartLocal(weekStartISO: string, day: number): string {
  const d = new Date(weekStartISO + 'T00:00:00');
  const result = new Date(d.getTime() + (day - 1) * 24 * 60 * 60 * 1000);
  return result.toISOString().slice(0, 10);
}

function formatDateCompact(date: Date): string {
  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  return `${day}.${month}`;
}

const getCategoryBadgeColor = (category?: string) => {
  switch (category) {
    case 'TYT': return '#4f46e5';
    case 'AYT': return '#d946ef';
    case 'YDT': return '#f97316';
    case 'LGS': return '#16a34a';
    default: return '#6b7280';
  }
};

// --- ANA BİLEŞEN ---
const WeeklyPlanDocument: React.FC<any> = ({ plan, planByDate, weekStart, subjects, topics, studentName, studentId }) => {
  const startDate = new Date(weekStart + 'T00:00:00');
  const endDate = new Date(startDate.getTime() + 6 * 24 * 60 * 60 * 1000);
  const dateRangeShort = `${formatDateCompact(startDate)} - ${formatDateCompact(endDate)}`;

  // İstatistikler
  const totalMinutes = plan.reduce((sum: number, p: any) => sum + p.allocated, 0);
  const totalHours = Math.floor(totalMinutes / 60);
  const totalMins = totalMinutes % 60;
  const uniqueSubjects = new Set(plan.map((p: any) => p.subjectId)).size;
  const uniqueTopics = new Set(plan.map((p: any) => p.topicId)).size;
  const totalTargetQuestions = plan.reduce((sum: number, p: any) => sum + (p.targetQuestionCount || 0), 0);

  // Hizalama için maksimum satır sayısı (A4 taşmaması için max 8 ile sınırlayalım veya dinamik bırakalım)
  const maxEntriesPerDay = Math.max(...DAYS.map(day => (planByDate.get(dateFromWeekStartLocal(weekStart, day.value)) || []).length), 1);

  const renderDaySection = (day: { value: number; label: string }) => {
    const dateISO = dateFromWeekStartLocal(weekStart, day.value);
    const date = new Date(dateISO + 'T00:00:00');
    const entries = (planByDate.get(dateISO) || []).slice().sort((a: any, b: any) => a.start.localeCompare(b.start));

    return (
      <View key={day.value} style={styles.daySection}>
        <View style={styles.dayHeader}>
          <Text style={styles.dayName}>{day.label}</Text>
          <Text style={styles.dayDate}>{formatDateCompact(date)}</Text>
        </View>
        <View style={styles.dayContent}>
          {/* TABLO BAŞLIĞI */}
          <View style={styles.tableHeader}>
            <View style={styles.colTime}><Text style={styles.tableHeaderText}>Saat</Text></View>
            <View style={styles.colCategorySubject}><Text style={[styles.tableHeaderText, {textAlign: 'left'}]}>Ders</Text></View>
            <View style={styles.colTopic}><Text style={[styles.tableHeaderText, {textAlign: 'left'}]}>Konu</Text></View>
            <View style={styles.colTarget}><Text style={styles.tableHeaderText}>Hedef</Text></View>
            <View style={styles.colSolved}><Text style={styles.tableHeaderText}>Çözülen</Text></View>
            <View style={styles.colCorrect}><Text style={styles.tableHeaderText}>Doğru</Text></View>
            <View style={styles.colWrong}><Text style={styles.tableHeaderText}>Yanlış</Text></View>
          </View>

          {/* DOLU SATIRLAR */}
          {entries.length > 0 ? entries.map((entry: any, idx: number) => {
            const subject = subjects.find((s: any) => s.id === entry.subjectId);
            const topic = topics.find((t: any) => t.id === entry.topicId);
            const category = subject?.category;
            
            return (
              <View key={idx} style={styles.topicRow}>
                <View style={styles.colTime}><Text style={styles.timeText}>{entry.start}-{entry.end}</Text></View>
                <View style={styles.colCategorySubject}>
                  {category && category !== '-' && category !== 'Okul' && (
                    <View style={[styles.categoryBadge, { backgroundColor: getCategoryBadgeColor(category) }]}>
                      <Text style={styles.categoryText}>{category}</Text>
                    </View>
                  )}
                  <Text style={styles.subjectText}>{subject?.name?.substring(0, 14)}</Text>
                </View>
                <View style={styles.colTopic}><Text style={styles.topicText}>{topic?.name?.substring(0, 18)}</Text></View>
                <View style={styles.colTarget}>
                    {entry.targetQuestionCount ? <Text style={styles.targetText}>{entry.targetQuestionCount}</Text> : null}
                </View>
                <View style={styles.colSolved}><View style={styles.inputBox} /></View>
                <View style={styles.colCorrect}><View style={styles.inputBox} /></View>
                <View style={styles.colWrong}><View style={styles.inputBox} /></View>
              </View>
            );
          }) : (
             <Text style={{ fontSize: 6, color: '#94a3b8', textAlign: 'center', padding: 4, fontStyle: 'italic' }}>Planlanmış çalışma yok</Text>
          )}

          {/* BOŞ SATIRLAR (Görünümü hizalamak için) */}
          {Array.from({ length: Math.max(0, maxEntriesPerDay - entries.length) }).map((_, idx) => (
             <View key={`empty-${idx}`} style={[styles.topicRow, idx === maxEntriesPerDay - entries.length - 1 ? styles.topicRowLast : {}]}>
                <View style={styles.colTime} />
                <View style={styles.colCategorySubject} />
                <View style={styles.colTopic} />
                <View style={styles.colTarget} />
                <View style={styles.colSolved} />
                <View style={styles.colCorrect} />
                <View style={styles.colWrong} />
             </View>
          ))}
        </View>
      </View>
    );
  };

  const dayPairs = [[DAYS[0], DAYS[4]], [DAYS[1], DAYS[5]], [DAYS[2], DAYS[6]], [DAYS[3], null]];

  return (
    <Document>
      <Page size="A4" style={styles.page}>
        <View style={styles.header}>
          <View style={styles.headerLeft}>
            <Text style={styles.title}>HAFTALIK ÇALIŞMA & SORU TAKİP PLANI</Text>
            <Text style={styles.subtitle}>Kişiselleştirilmiş Öğrenme Programı</Text>
          </View>
          <View style={styles.headerRight}>
            <Text style={styles.studentName}>{studentName || 'Öğrenci Adı'}</Text>
            <Text style={styles.dateRange}>{dateRangeShort}</Text>
          </View>
        </View>

        <View style={styles.statsRow}>
          <View style={styles.statCard}><Text style={styles.statValue}>{totalHours}s {totalMins}dk</Text><Text style={styles.statLabel}>Toplam Süre</Text></View>
          <View style={styles.statCard}><Text style={styles.statValue}>{plan.length}</Text><Text style={styles.statLabel}>Etüt Sayısı</Text></View>
          <View style={styles.statCard}><Text style={styles.statValue}>{uniqueSubjects}</Text><Text style={styles.statLabel}>Farklı Ders</Text></View>
          {totalTargetQuestions > 0 && (
             <View style={[styles.statCard, { borderColor: '#fdba74', backgroundColor: '#fff7ed' }]}>
                <Text style={[styles.statValue, { color: '#ea580c' }]}>{totalTargetQuestions}</Text>
                <Text style={styles.statLabel}>Hedef Soru</Text>
             </View>
          )}
        </View>

        <View style={styles.mainContent}>
          <View style={styles.column}>{dayPairs.map((pair) => renderDaySection(pair[0]))}</View>
          <View style={styles.column}>{dayPairs.map((pair) => pair[1] ? renderDaySection(pair[1]) : <View key="empty" style={{flex:1}} />)}</View>
        </View>

        <View style={styles.footer}>
          <Text style={styles.notesTitle}>Haftalık Değerlendirme</Text>
          <View style={styles.notesGrid}>
            <View style={styles.noteColumn}><View style={styles.noteBox} /><Text style={styles.noteLabel}>Öğrenci Görüşü</Text></View>
            <View style={styles.noteColumn}><View style={styles.noteBox} /><Text style={styles.noteLabel}>Veli Notu</Text></View>
            <View style={styles.noteColumn}><View style={styles.noteBox} /><Text style={styles.noteLabel}>Rehber Öğretmen</Text></View>
          </View>
          <View style={styles.branding}>
            <Text style={styles.brandText}>Rehber360 - Akıllı Çalışma Sistemi - {new Date().toLocaleDateString('tr-TR')}</Text>
          </View>
        </View>
      </Page>
    </Document>
  );
};

// --- PDF OLUŞTURMA FONKSİYONU ---
export async function generateTopicPlanPDF(
  plan: PlanEntry[],
  planByDate: Map<string, PlanEntry[]>,
  weekStart: string,
  subjects: Subject[],
  topics: Topic[],
  studentId: string,
  studentName?: string,
  options: { download?: boolean; print?: boolean } = { download: true, print: false }
) {
  const blob = await pdf(
    <WeeklyPlanDocument
      plan={plan}
      planByDate={planByDate}
      weekStart={weekStart}
      subjects={subjects}
      topics={topics}
      studentId={studentId}
      studentName={studentName}
    />
  ).toBlob();

  const fileName = `Calisma_Plani_${weekStart}_${studentName || 'Ogrenci'}.pdf`;

  if (options.print) {
    const url = URL.createObjectURL(blob);
    const printWindow = window.open(url, '_blank');
    if (printWindow) {
      printWindow.onload = () => {
        printWindow.print();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      };
    }
  } else if (options.download) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(url);
  }
  return blob;
}
